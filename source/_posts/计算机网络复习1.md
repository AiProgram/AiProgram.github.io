---
title: 计算机网络复习1
date: 2020-07-25 16:55:21
tags:
categories:
- 计算机网络
---

# OSI，TCP/IP协议栈

## OSI，TCP/IP分层

<!-- more -->

+ OSI分七层，自底向上：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层
+ TCP/IP分四层：网络接口层（物理、链路合并）、网络层、传输层、应用层（会话、表示、应用合并）。
+ 学习中使用中和两者的五层结构：物理、链路、网络、传输、应用层（会话、表示、应用层合并）。
+ 不同层次设备名称：
  + 物理：转发器
  + 链路：网桥
  + 网络：路由器
  + 网络以上：网关。但是路由器也常被称为网关。

## 五层分层的作用及其协议栈

### 物理层（Physical Layer）

+ 物理层主要规定媒体传输接口的机械、电气、功能、过程特性
+ 物理层不考虑传输的是怎样的比特流，而是考虑比特流怎样传输，所以物理层没有所谓的网络协议栈。

### 数据链路层（Data Link Layer）

#### 链路层作用

+ 在网络上，不同的两个主机之间有可能通过多个中间主机连接。但是也有可能直接通过一段链路连接，且该链路上不存在中间主机。数据链路就是负责后一种最简单链路。

#### 链路层组成

+ 链路指的是物理链路，只有加上其上承载的通信协议才成为完整的数据链路。
+ 现在的网络适配器一般包含了物理、数据链路两层的功能。
+ 数据链路对应数据单元---`帧`
+ 注意：
  1. 到数据链路为止，我们熟悉的**TCP/IP**协议都还**没有出现**
  2. 正因为TCP/IP都还在上面的网络层，所以更高级的协议更是**没有出现**
+ 计算机网络协议采用**类似套娃**的形式，这点和Java 的IO结构很像。除了链路层外，其他层**均适用以下概括**。
  1. 高层协议把自己的数据（包）传递到下一层，低层可能会在数据外加上一层封装，也有可能把高层数据分割成多份后在每一份外加上一层封装。低层协议所加的封装保存的就是协议所需的信息，例如数据长度、协议标志、数据源、接收者等等。
  2. 这样数据依次向下传递直到物理层发送，协议就形成了一个高层协议在栈底的栈。而接收时协议栈出栈，每出栈一层协议，该层协议都会处理自己的封装，还原成高层协议需要的数据。
  3. 如此一来，各层协议各司其职，都只需要处理自己负责的数据传输即可。

#### 链路层协议

+ 链路层协议有多种，但是它们全部需要解决三大问题：**封装成帧、透明传输、差错检测**

##### 封装成帧

+ 链路层对网络层（IP协议）传下来的数据使用封装：帧首部--数据段--帧尾部
+ 数据端的最大长度由MTU规定
+ 链路协议采用帧定界符来分割数据段的边界。帧前部使用SOH控制字符，帧尾部使用EOT控制字符，这两个字符都是ASCII码中不可打印的字符。当然ASCII码对应着二进制表达，它们就是两种特殊的二进制码。

##### 透明传输

+ 封装成帧中的帧界定符显然有可能与数据段中的数据重合，此时如果不加以区分，那么数据段部分就有可能被错误的定位。

### 网络层（Network Layer）

#### 注意点

+ 网络层主要有IP协议、ARP（Address Resolution Protocol）、ICMP（Internet Contorl Message Protocol）、IGMP（Internet Group Management Protocol），但是**这几个协议不是完全独立、并列**的。IP需要用到ARP，ICMP、IGMP则需要用到IP协议。

#### IP地址分配

+ IP地址（不含端口号）实际由两部分组成：网络段+主机号。正是因为有了两部分所以用子网掩码来分开。
+ ABCD四类地址[待补充]



### 传输层（Transport Layer）

#### 传输层作用

+ 为两台**主机间的进程**通信提供服务。
  + 显然，网络的协议至下而上，服务的对象范围越来越小，网络层时服务的对象还可以是两台主机到了这里就是主机里的进程了。
+ 到了传输层，通信对象由主机缩小为主机进程，主机是一个独立的个体但是进程在一个主机上有很多个。所以传输层出现了**复用**、**分用**分别对应发送和接收过程。
  + 在复用、分用中多个进程使用同一个传输层协议，通过首部信息去区分。

#### UDP（User Datagram Protocol）协议

+ 除了传输层协议基础的复用、分用功能，UDP只增加了差错检测功能。
  + 不要以为数据链路层有了差错检测，传输层的差错检测就是多余的了。因为差错不止出现在链路层管辖的一段链路上，下层IP协议的处理、路由器的处理、电路出错都有可能导致数据在链路层正确而传输层出错。可以参考：[在计算机网络中数据链路层和传输层都有流量控制和差错控制他们有什么区别？知乎](https://www.zhihu.com/question/294657294)
+ 因为UDP的功能极少，TCP的大部分功能UDP都没有。

##### UDP特点

1. 

#### TCP（Transmission Control Protocol）

##### TCP特点

1. TCP之所以不同于UDP，会主动拆包或者转包（把数据切分或者组合），也可以看作TCP的流量控制功能的一个效果或者说要求，因为流量控制要求TCP协议自行控制每次传输数据流的长度而不是应用直接管理。
   + 正是因为有了拆包和装包，才会由TCP沾包的问题。[待补充完整]
2. TCP报文中，**ACK，ack，seq**这三者是完全不同的。**ACK**和**SYN**，**FIN**类似是只能设置成0或者1的控制位，其中它们分别表示确认(同意)，同步（请求建立连接），结束（请求断开连接）。而**seq, ack**则分别是序号、确认号，一般用于停止等待协议、自动重传（AQS）、流量控制（滑动窗口）等功能中。注意：**seq，ack**同样会参与到TCP的连接建立、断开中，这里特别需要和**ACK**区分。此外：仅有ACK=1时ack字段才有意义。
3. TCP中的**ack**报文确认的是对方发送的报文数据序号，而**seq**是自己发送的报文数据序号。由于TCP是全双工通讯，双方都可以发送，所以同一方发送的**ack,seq**两个序号可以完全不相关。有一个例外就是即使没有发送数据，但是如果**SYN=1/FIN=1**（即属于连接管理的报文），那么也需要消耗一个序号**seq**，这里其实是为了让对方回复的**ACK=1**确认报文对应“唯一”的一个SYN/FIN报文。
4. TCP中的流量控制和拥塞控制作用是完全不同的：流量控制主要考虑到接收方的缓存区大小有限，需要控制发送方的发送速度以避免来不及处理。而拥塞控制考虑的是双方间网络质量对传输速度的限制，需要调整速度达到最大传输效率。
5. TCP的慢启动、拥塞避免（与拥塞控制区分）、快恢复、快重传**均属于拥塞控制**。注意：慢启动的慢特指启动的初始值小，不是增长速度。
   1. 慢启动主要由拥塞窗口(cwnd，注意与流量控制的rwnd区分)控制，cwnd在慢启动初期每成功一个传输轮次就增大一倍，直到碰到预设的慢启动门限（阈值，ssthresh）。超过了慢启动门限就转入拥塞避免算法控制的范畴了。
   2. 由于慢启动门限是慢启动与拥塞避免的交界处，显然它越接近于实际的值越好，所以传输中动态调整的除了拥塞窗口外就是慢启动门限了，后者取上一次cwnd/2.
6. **简洁总结TCP建立连接为什么是三次而不是两次握手，TCP断开连接为什么是四次（主动方为何要等待被动方）**

   + 建立连接的第三次握手是为了让双方都得知自己和对方的发送、接收情况。如果只有两次握手，则有可能客户端发现未成功连接而服务端没能发现连接不成功，此时无效链接消耗大量服务其资源。
   + TCP的四次握手相比三次握手，主要是被动方的ACK报文和FIN报文不相同，三次握手中被动方的SYN和ACK报文是合二为一的。这是因为主动方能确认自己不再发送数据，但是被动方可能由于原因无法马上停止发送数据，所以被动方的ACK和FIN报文一前一后是有等待间隔的。

