---
title: LeetCode刷题心得-1
date: 2020-08-11 10:20:04
tags:
categories:
- 算法

---



**本文章用于记录LeetCode刷题的心得，包括如何思考、代码如何高效无错实现等**

<!-- more -->

## [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

> 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
>
>  示例:
>
> 给定 1->2->3->4, 你应该返回 2->1->4->3.
>

+ 本题可以与k反转链表和链表逆序联系起来，相当于节点两两内部逆序

### 本题首先可以用递归做

+ 递归需要使用返回值传回交换后本段（本题是长度为2的逆序串）的头节点
+ 因为返回的必须是整段的头节点不能是段内其他节点，所以对于一段的处理最好放在一个递归函数内处理，**不要试图每次递归处理一个节点**

### 本题还可以使用遍历做

+ 遍历的话首先需要处理交换的两个节点，我们称为$Node_1,Node_2$
+ 其次考虑到交换时$Node_1$的父亲的next指针也需要修改，所以$Par_1$也需要处理
+ 在确定了所有需要处理的指针后，再考虑如何初始化（用dummy节点避免讨论）、移动这三个指针。
+ 考虑到指针的交换非常复杂，对于本题可以画一个长度为2、3的链表进行模拟，其中**原指针用实线，修改的指针用虚线，为每一个新连接选择正确的修改顺序**
+ 此外，链表逆序除了一个个节点逆序，还可以使用**头插法，这实际也是链表实现栈的方法**。只不过这样可能需要另起一个dummy（空头）节点用于保存逆序链表。

## [28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

> 实现 strStr() 函数。
>
> 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。
>

+ 本题实际上就是要求实现：在一个给定串中寻找模式字串出现的一个位置。

### 本题最优秀的做法应该是KMP算法

+ KMP算法这里不再详细介绍，它的核心是求相同前后缀最大长度数组，然后转为Next数组。
+ 注意：使用Next数组时是模式串指针移动而不是被匹配串的指针移动。
+ 求Next数组的过程也看做模式串内部的匹配比较好理解，可见[如何更好地理解和掌握 KMP 算法? - 海纳的回答 - 知乎 ](https://www.zhihu.com/question/21923021/answer/281346746)
+ 不同版本KMP的$Next[0]$似乎取值不同，上述知乎解法统一取-1，是为了标志此处整个模式串完全失配重新开始，遇到此情况统一加一进入$Pattern[0]$准备重新开始对比。
+ 知乎解法的另一点就是前后缀数组向后移动一位才能得到$Next[]$。

```c
int KMP(char * t, char * p) 
{
	int i = 0; 
	int j = 0;

	while (i < strlen(t) && j < strlen(p))
	{
		if (j == -1 || t[i] == p[j]) 
		{
				i++;
           		j++;
		}
	 	else 
           		j = next[j];
    }

    if (j == strlen(p))
       return i - j;
    else 
       return -1;
}
void getNext(char * p, int * next)
{//着重理解：求Next数组是Patter串的内部匹配（使用求出的Next数组）过程
	next[0] = -1;
	int i = 0, j = -1;

	while (i < strlen(p))
	{
		if (j == -1 || p[i] == p[j])
		{
			++i;
			++j;
			next[i] = j;
		}	
		else
			j = next[j];
	}
}
```

### 本题还可以使用字符串Hash

+ 字符串hash可以把字符串看作一个$N$进制数，其中$N$就是每一位字符的种类数。但是显然这很容易数值溢出，可以使用求余的方法避免，考虑到快速求余以及取值范围，我们对$2^{31}$求余即可，且本处使用$n\&(2^{31}-1)$即可快速计算余数。
+ 考虑到有取余，所以Hash相同时还需要进一步比对是否真的相等。

## [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)

+ 本题主要是关于全排列(字典序)的，但是要求从任意一个中间态求下一个排列，所以不能使用常规的递归算法了。

+ 本题主要需要注意几点：

  1. 首先记住全排列的一个样例用于回忆推导：

  > 1,2,3,4,5
  >
  > 1,2,3,5,4
  >
  > 1,2,4,3,5
  >
  > 1,2,4,5,3
  >
  > 1,3,2,4,5
  >
  > 1,3,2,5,4

  2. 然后记住寻找交换的数对分两步：第一步：找到最靠后(从后向前找)的一对相邻的升序数对$n_1<n_2$，$n_1$将被用于交换。第二步：找到最靠后(从后向前找)的一个数$n_3$满足$n_3>n_1$。则$n_1,n_3$交换。
  3. 交换了一次过后，假设原来$n_1$的索引是$i$，则需要让$arr[i-1,arrLen)$也就其后面的数组部分变成升序。这里可以省事直接排序，也可以使用反转的方法。因为只有当$arr[i-1,arrLen)$是降序时我们才需要反转它为升序。