---
title: Java面向对象
date: 2020-07-27 21:08:58
tags:
categories:
- Java
- 基础
---

# Java面向对象基础

## 继承基础知识

<!-- more -->

+ 父类、超类、基类都是同一个概念
+ 面向对象三大特性中，继承是多态的基础，多态只在具有继承关系的类之间发生
+ 区分**重载（Overload）**与**重写（Override）**：
  1. 重载发生在一个类的内部，当一个类内有多个同名方法时，编译器根据方法的参数数量、类型、个数来区分该调用哪个方法。注意：重载不依据返回值区分，即仅有返回值不同不能重载。
  2. 重写发生在继承类之间，子类编写与父类相同的方法，重写的方法名、返回值、参数列表均相同，但是**权限修饰符可以不相同**。由于父类的private方法子类无法访问，显然也无法重写。注意：子类只能缩小重写方法的权限，例如public->protected，但是不能扩大。
  3. 从名字上看，重写是外壳不变，**内部重写**。而重载是**重新载入方法**，外壳也变了。
  4. 重写是父类、子类间的多态，而重载是类内部的多态。
+ 在构造方法上，父类如果有无参构造器子类可以默认调用，但是没有的话就必须用super关键字自行调用有参构造器。
+ 在有继承、静态的情况下，子/父类的属性、代码块、构造器的构造顺序：
  
  1. 当存在静态和非静态部分时，静态部分先于非静态部分初始化。
  2. 当规则 1 无法判断时，父类部分先于子类初始化。
  3. 当规则 1，2均无法判断时，初始化顺序：属性->代码块->构造器。
  4. 1，2，3全部相同时，按照定义的顺序执行。
  5. 综合规则 1，2，3，我们有最终顺序
  
  >     1. 父类的静态成员变量
  >     2. 父类的静态代码块
  >     3. 子类的静态成员变量
  >     4. 子类的静态代码块
  >     5. 父类的成员变量
  >     6. 父类的代码块
  >     7. 父类的构造函数
  >     8. 子类的成员变量
  >     9. 子类的代码块
  >     10. 子类的构造函数

----

### 补充：代码块知识

+ 在Java中，使用`{}`包裹起来语句的我们称为代码块
+ 代码块放在普通方法中就是**普通代码块**，独立放在类中（与方法、属性并列）且不加`static`就是**构造代码块**，加上了static修饰的就是**静态代码块**。
+ 构造代码块每一次构造类都会运行一次，多个平等的构造代码块按定义顺序执行。
+ 静态代码块在JVM加载类时就运行一次且仅运行这一次。

---

+ 所有的类均继承自`java.lang.Object`。
+ `final`修饰类时，类不能被继承，且其中的方法均隐式被final修饰。但是变量没有。`final`单独修饰的方法不能被重写。
+ 类似于`final`，`static`修饰的方法也不能重写。
+ **重写**还受到了权限修饰符的限制，子类不能访问的方法无法重写。所以一个包中的子类不能重写父类private方法，而不在一个包中的的子类不能重写父类private、默认权限方法。

## 多态基础知识

+ 多态必要条件：继承、重写、父类引用指向子类对象（向上转型）。
+ 多态下，父类引用调用被子类重写的方法执行的 仍然是**子类重写后的方法**。
+ 而如果在多态下还是想调用父类被重写前的方法，需要`super`显示调用。
+ 在**C++**中，多态由虚函数实现，但是Java中没被final修饰的方法默认就是虚函数。

## 抽象基础知识

+ Java中抽象类是被`abstract`修饰的类

+ 抽象类除了不能被实例化只能被继承外，其他包括方法、属性等等都可以和普通类一样

+ 方法也可以被`abstract`修饰，此时该方法必须被子类重写。当一个类有了抽象方法，抽象方法导致该类必须被子类继承才能正常工作，同时子类要么实现抽象方法要么声明自己是抽象类。所以有抽象方法的类一定是抽象类。

+ 抽象方法没有方法体，形式类似于函数声明，例如

  ```java
  public abstract double computePay();
  ```

+ **注意**：构造函数、static方法不能是抽象方法。

## 封装基础知识

+ 封装是类对内部实现的隐藏，一般使用`private`权限实现。

## 接口基础知识

+ 类似普通类，接口的源文件也保存在`.java`文件中，字节码文件也保存在`.class`文件中。
+ 只有`static`和`final`变量可以放在接口中。
+ 默认情况下，不特意指定的话，接口是被`abstract`隐式修饰的，接口的方法是被`public abstract`隐性修饰，变量被`public static final`隐性修饰。不能人为设置与上述修饰符矛盾的修饰符，会报错。
+ 抽象类可以有静态代码块和静态方法，但是接口不能有。
+ 但是在JDK 1.8以后接口可以有静态方法以及方法体，使用`default`标记。
+ 仅有抽象类可以在实现接口时不实现所有的方法。
+ 在实现接口的方法时，方法名、参数必须一致，返回值必须兼容。
+ **注意**：接口可以继承接口，同样使用`extends`关键字，此外接口可以继承多个接口，例如

```java
public interface Hockey extends Sports, Event
```

+ 在接口的继承中，我们经常用到没有任何方法的空接口，这种接口可以称为标记接口，例如

```java
package java.util;
public interface EventListener
{}
```

## 枚举类基础知识

+ 枚举类的关键字：`enum`，使用与普通数据类型更相似，注意与class定义方式区分：

```java
enum Color 
{ 
    RED, GREEN, BLUE; 
} 
```

+ 枚举类是一种特殊的类，例如上述的Color枚举类的每一种枚举对象都是一个Color类对象，且被`public static final`修饰：

```java
class Color
{
     public static final Color RED = new Color();
     public static final Color BLUE = new Color();
     public static final Color GREEN = new Color();
}
```



+ 枚举类是类，且能有自己的方法、变量、构造函数，**注意**：其构造函数只能是private，这是因为枚举类不允许随意修改枚举数量。
+ 枚举类有三个常用函数：
  1. `values()`：数组形式返回所有枚举值。
  2. `ordinal()`：int 形式返回本枚举值的索引。
  3. `valueOf`：依据枚举值名称获得对应枚举值。