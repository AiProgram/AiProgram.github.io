---
title: 算法编程心得-1
date: 2020-07-24 12:00:20
tags:
categories:
- 算法
- 面试编程题
---

**本文章主要是我准备面试学习算法编程题时的收获与总结，涉及面试编程以外的算法不在此介绍**

<!-- more-->

## 单调队列与单调栈

+ 参考的文献(更详细的说明)，可见文章[线性结构 —— 单调栈与单调队列](https://blog.csdn.net/u011815404/article/details/86896303)
+ 单调队列和单调栈的最大特点：无论何时，队列、栈中的元素总是有序的。本处我们均假设是升序的：即从栈顶到栈底是升序的，从队尾到队首是升序的。
+ 如何实现的呢？
  + 对于单调栈：每一次添加元素A，在A入栈前，把栈顶所有小于A的元素出栈，然后再将A入栈。
  + 对于单调队列：每一次入队元素A，在A入队前，把队尾所有小于A的元素出队，然后再将A入队。
+ 注意：在单调队列的操作中，我们用到了队尾元素出队，这在单端队列中显然无法实现，所以我们需要双端队列Deque来实现单调队列。
+ 它们的用处：
  + 假设我们把一个数组从左至右不断压入单调栈，从元素A入栈上看：我们找到了A左侧第一个不小于A的元素B，从元素A出栈时看：我们找到了A右侧第一个大于A的元素C。显然，区间 $(pos(B),pos(C))$ 上，A都是最大值。
  + 对于单调队列，如果我们把它与一个普通的队列组合起来，元素对应相同操作。则我们能获得普通队列中任意时刻的最大值：当前单调队列中的队首值。
  + 单调队列可以很轻松的维护队列的最大值，又因为队列本质看作一个区间，所以在滑动窗口最大值中也有应用。滑动窗口最大值问题：给出窗口长度$n$，给出一段数组，使用窗口划过该数组，并求滑动时的窗口任意时刻最大值。这里我们把窗口前进端看作队尾，前进端的后方视作队首，就可以使用单调队列优化了。

## 二分查找

+ 二分查找是一个很常见，但是变种问题的细节却非常多的问题
+ 要实现二分查找，需要注意三个部分：
  1. while循环的条件
  2. mid的计算方法
  3. 根据对比修改left、right边界
  4. 返回的值以及是否需要做扫尾判断
+ 这里的思考主要参考自[二分查找、二分边界查找算法的模板代码总结](https://segmentfault.com/a/1190000016825704)

### mid计算

+ mid计算一般取$(left+right)>>1$。
+ 考虑到$left+right$可能溢出，所以建议采用$left+(right-left)>>1$。

### 如何修改left、right边界

这里我们结合特例，形象的记忆方法最好，假设有一个非降序排列（可以有重复元素）的数组arr：

| index | 0    |  1   |  2   |  3   |  4   |  5   |
| :---: | :--- | :--: | :--: | :--: | :--: | :--: |
|  num  | 0    |  2   |  4   |  4   |  5   |  11  |

+ 第一种基础问题：key为4，我们只需要找到任意一个key就返回
  1. 若arr[mid]==5>key，则我们可取right=mid-1，因为arr[mid]!=4可以丢弃。
  2. 若arr[mid]=2<key，则可以取left=mid+1，因为arr[mid]!=4可以丢弃。
  3. 若arr[mid]==4，此时mid=2，3，返回即可。
+ 第二种变形问题：key为4，我们要找到最右侧的4（index=3），也即4的边界。
  1. mid=4时同

## Tarjan算法求强连通分量

+ 明确：tarjan算法用于求图的最大强连通分量，在一个强连通分量中任意两点都是可达的，最大强连通分量无法加入更多的点继续构成强连通分量。
+ tarjan算法仅用于有向图，无向图的强连通分量显然使用DFS、BFS就能求出来。

### 算法细节

+ 强连通分量中的顶点至少处在一个环中，且至少有一个大环包含所有顶点，不然就有点对不是互相可达的。
+ 如果能找到这个最大环，那么强连通分量就找到了。为了找环，tarjan算法引入了DFS。

1. 首先考虑两个值，**DFN[]**定义为DFS中顶点的时间戳，所以DFN[]在DFS的新访问点中递增且所有点的DFN不相同。**Low[]**定义为该点所能到达的顶点的最小DFN。

2. 对于无环的顶点显然Low[i]=DFN[i]也即它只能到自己为止，但是如果是位于环上的顶点，则它们能返回DFS路径中DFN更小的点，且环上所有点的Low[]都应是环上DFN[]的最小值。

3. **Low[]**如何求呢？一个顶点能到达的最小DFN是由它的DFS路径上的子孙们决定的，所以Low[]应在DFS准备回溯时才能更新为最终值（更新为自己和子孙中DFN最小值）。

4. 有了DFN和Low如何发现最大强连通量？对于强联通分量上的某个点$i$，我们必有$Low[i]\leq DFN[i]$，同时只有当一个点$j$是联通分量上的最小DFN时才有$Low[j]= DFN[j]$，所以我们可以用$Low[i]=DFN[j]$定位强连通分量上的所有点$i$。

5. 如何保证上述方法找到的点属于一个**最大**强连通分量呢？这是因为小一点的强连通分量上的$Low[]$会被更大强连通分量上的子孙的Low值替换。这一点我们考虑一个简单的范例就能模拟出来：

   > 考虑图：$1\rightarrow 2\rightarrow 3\rightarrow 4$，$3\rightarrow 2$，$4\rightarrow 1$

   可以看到有一个小强联通分量$2,3$，最大强连通分量$1,2,3,4$，显然$Low[3]=\min(Low[3],Low[4])=1$，所以大联通分量覆盖了小的。

6. 我们如何方便的依次输出一个强连通分量？靠DFN再一个个查找效率很低，所以我们使用栈缓存DFS的元素，在发现$Low[j]=DFN[j]$时弹出所有元素就属于同一个最大强连通分量。

7. 最后，一个图可能包含多个极大强连通分量，所以我们需要在DFS外围再用循环遍历所有点来找到所有的极大联通分量。

### 思维发散

+ 我们可以发现tarjan算法中用一个最小DFN的根来定位同一个最大强连通分量中的所有点，这个思想与并查集非常相像，事实上两个算法的发明者是一个人。

### Tarjan范例代码

```java
void dfs(int x) {
    dfn[x] = low[x] = ++tot; //都初始化为++tot时间戳
    stack_[++top] = x; //点x入栈
    exist[x] = 1; //表示点x在栈中
    for (int i = head[x]; i; i = cow[i].nxt) {
        if (!dfn[cow[i].to]) {
            //如果与它相连的这个点还没有被遍历
            dfs(cow[i].to);
            low[x] = min(low[x], low[cow[i].to]);
        } else if (exist[cow[i].to]) {
            //如果与它相连的这个点在栈中, 表示它们在同一个连通分量中
            low[x] = min(low[x], low[cow[i].to]);
        }
    }//end for

    if (low[x] == dfn[x]) {//输出一个强连通分量
        //如果节点x是强连通分量的根
        id++; //每个连通分量的标号
        do {
            color[stack_[top]] = id;
            num[id]++;
            exist[stack_[top]] = 0;
        } while (x != stack_[top--]);
    }
}
for (int i = 1; i <= n; i++) {
    if (!dfn[i]) {
        dfs(i);
    }
}
```

代码参考自：[链接](https://juejin.im/post/6844904056821923848)

